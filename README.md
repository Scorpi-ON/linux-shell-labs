# linux-shell-labs
Набор лабораторных работ по операционным системам, представляющих собой скрипты Linux Shell различной сложности

<h2>Простые команды</h2>

<h3>Задание</h3>
В соответствии с вариантом задания написать однострочную команду, расширяющую функциональные возможности ОС Unix.

<h3>Запуск</h3>
Для загрузки команд в оболочку выполните команду из корня репозитория:
```shell
source simple.sh
```
После этого они станут доступны.

Чтобы реализовать поддержку скрытых файлов, везде, где применялась команда `ls -l`, необходимо дописать флаг `-A`.

<details>
<summary><h3>Команды</h3></summary>
 
**1.** `lx` **— вывести список файлов указанного каталога, у которых права на чтение, запись и выполнение только для создателя файла (т.е. rwx------), отсортировать их по имени в обратном порядке.**

Команда ls -lh $1 выводит всё содержание указаного каталога, а grep находит те строки, которые начинаются на -rwx------ (т. е. содержат файлы с требуемым набором прав).

<img width=75% src="https://github.com/user-attachments/assets/f65c2a91-8812-4d78-9031-f25834ffb084"/>
<br>
<br>

**2.** `pu` **— посчитать количество процессов, запущенных указанным пользователем.**

Команда ps с аргументом -u выводит список процессов, запущенных указанным пользователем. Модификатор h убирает заголовок перед списком. Для подсчёта остаётся вызвать команду wc. Флаг -l, означает подсчёт только строк (а не слов и символов).

<img width=75% src="https://github.com/user-attachments/assets/cb2611c9-811b-4c5c-8d79-7b21e35cd850" />
<br>
<br>

**3.** `pt` **— посчитать кол-во процессов, запущенных с указанного терминала.**

Команда ps c модификатором t выводит список процессов, запущенных с указанного терминала. Для подсчёта вновь используем модификатор h и передачу команде wc.

<img width=75% src="https://github.com/user-attachments/assets/9a67365e-6457-4177-baea-5867d9a53aea" />
<br>
<br>

**4.** `nx` **— количество исполнимых файлов в указанном каталоге.**

С помощью ls -l $1 выведем содержимое указанного каталога. Командой grep с шаблоном «^-.*x.* » найдём все строки, начинающиеся на - (такие строки описывают файлы) и содержащие x в триадах прав (хотя бы одна x означает, что файл является исполняемым для одной из групп пользователей). Флаг -с команды grep означает, что нужно вывести только число найденных строк.

<img width=75% src="https://github.com/user-attachments/assets/7b019955-2ee5-4677-ad59-e985868d397d" />
<br>
<br>

**5.** `npu` **— посчитать количество терминированных процессов, запущенных указанным пользователем.**

Терминированные процессы имеют статус T в списке процессов. Поскольку нам необходимо узнать их количество, воспользуемся аргументом -o и передадим ему одно поле — stat (статус процесса). Аргумент -u $1 выведет процессы указанного пользователя. Остаётся найти количество нужных статусов при помощи grep -c ‘^T’.
На скриншоте было создано и прервано 3 процесса, чтобы продемонстрировать работу скрипта.

<img width=75% src="https://github.com/user-attachments/assets/3b0b33e6-e2e6-4dd7-8ee0-c989699407b0" />
<br>
<br>

**6.** `mp` **— количество процессов, запущенных определенного числа.**

Запустим команду ps с модификатором h и флагом е для получения всех процессов без строки заголовка. Чтобы выбрать только даты, добавим аргументы -o lstart и -D %d.%m.%y. Теперь для поиска и подсчёта можно вводить дату в привычном формате.

<img width=75% src="https://github.com/user-attachments/assets/04004433-fdc6-4f69-b583-bde2f57b3f65" />
<br>
<br>

**7.** `tu` **— посчитать количество терминалов, с которых запущены процессы в текущий момент времени.**

Команда who в числе прочих данных выводит список активных терминалов. Подсчитаем их с помощью wc -l. При этом, поскольку с терминала pts/0 процессы не запускаются, отнимем от подсчитанного значения 1. Остаётся только вывести полученное арифметическое выражение с помощью echo.

<img width=75% src="https://github.com/user-attachments/assets/2892512e-de5f-4ef8-b6ae-a9c2f3f2b120" />
<br>
<br>

**8.** `bp` **— вывести информацию об указанном количестве процессов, имеющих наибольшее время использования процессора.**

Выведем список всех процессов командой ps -e. Также после аргумента -o укажем необходимые поля для вывода: пользователь, идентификатор процесса, процессорное время и команда. Чтобы отсортировать список по процессорному времени по убыванию используем аргумент --sort=-time. Чтобы вывести указанное количество строк из полученного списка, используем команду head. Аргумент -n задаёт число строк для вывода. Поскольку строка заголовка в данном случае нужна, к указанному числу прибавим 1.

<img width=75% src="https://github.com/user-attachments/assets/ce81da0f-5ae7-45e9-9052-2dea443de266" />
<br>
<br>

**9.** `bf` **— вывести информацию об указанном количестве файлов, имеющих наибольший размер.**

С помощью флага -S отсортируем вывод команды ls -lh по размеру файлов. Чтобы отобрать файлы из содержимого каталога, применим grep ‘^-‘. Чтобы выбрать только указанное количество файлов из топа, используем head -n $2.

<img width=75% src="https://github.com/user-attachments/assets/31071b65-2a57-4a34-91df-e17a68bd50e3" />
<br>
<br>

**10.** `fm` **— посчитать кол-во директорий в указанном каталоге, у которых права доступа: rwxrwxrwx.**

Выведем содержимое указанного каталога, после чего используем grep с шаблоном ‘^drwxrwxrwx’ (выбирает директории с полной триадой прав) и подсчитаем с помощью флага -c.

<img width=75% src="https://github.com/user-attachments/assets/eacb8836-a9bd-4c5b-aa4d-fe512c14ecb8" />
<br>
<br>

**11.** `ml` **— вывести информацию об указанном количестве файлов, имеющих наибольшее число связей.**

Число связей файлов выводится во втором столбце вывода команды ls -l. Поэтому, чтобы отсортировать файлы и директории по числу связей, передадим команде sort аргументы -rnk2 (числовая сортировка по убыванию по второму столбцу). Чтобы получить указанное количество файлов, применим команду head.

<img width=75% src="https://github.com/user-attachments/assets/58868b27-3d00-40bf-8a5e-43ffe5370d5f" />
<br>
<br>

**12.** `ll` **— список пользователей-владельцев файлов в указанном каталоге.**

Чтобы вычленить пользователей владельцев из содержимого каталога, применим команду awk. Чтобы выбрать из них уникальные имена, используем sort -u.

<img width=75% src="https://github.com/user-attachments/assets/703ea097-8f69-4cfb-9571-124b732f6f69" />
<br>
<br>

**13.** `rl` **— вывести список всех файлов, с датой создания, равной текущему числу.**

Для вывода содержимого каталога с датой создания применим аргумент --time=creation, а чтобы эта дата была в более привычном формате, добавим аргумент --time-style +%d.%m.%y. Текущую дату получим в этом же формате командой date. Остаётся только найти строчки, содержащие эту дату (а также - в начале строки как признак файла), при помощи grep.

<img width=75% src="https://github.com/user-attachments/assets/12b33de6-019e-40c5-9cb6-f5a56f0c2f44" />
<br>
<br>

**14.** `lr` **— вывести 5 последних процессов, запущенных root.**

По аналогии с командой bp (см. пункт 8) выведем интересующие нас колонки процессов root и с помощью аргумента --sort=-start отсортируем по времени создания по убыванию.

<img width=75% src="https://github.com/user-attachments/assets/5d401952-37ac-46b1-9795-cd9bb2d31f1c" />
<br>
<br>

**15.** `rc` **— вывести 5 процессов, запущенных studentom.**

Выведем все процессы, запущенные указанным пользователем, после чего выберем 5 из них (а также строку заголовка).

<img width=75% src="https://github.com/user-attachments/assets/a0c9883f-a80f-4922-8a18-7f8c8e2f1d0f" />
<br>
<br>

**16.** `cu` **— посчитать, какое количество пользователей сейчас работает в системе (имя уникально).**

Выведем работающих на данный момент пользователей командой w, отбросим строку заголовка флагом -h и подсчитаем оставшиеся строки пользователей.

<img width=75% src="https://github.com/user-attachments/assets/577b7673-b0ee-493d-86a7-7a71f1516070" />

</details>

<h2>Сложные скрипты</h2>
<h3>Задание</h3>
Разработать программу-скрипт средствами Shell. Программа должна запускаться в следующем формате: `./script.sh Time NumItem ItemFile`, где:
 
- Тime — длительность промежутка времени;
- Numltem — количество пунктов меню;
- ItemFile — текстовый файл с наименованием пунктов меню.

Скрипт должен выполнять следующие действия:
1. При запуске контролировать наличие необходимых параметров и при необходимости выдавать сообщение об ошибке.
2. Выводить сообщение-подсказку о выполняемом задании.
3. Формировать меню с требуемым количеством пунктов. Информация о названии пунктов берется из текстового конфигурационного файла.
4. Реализовывать выполнение пунктов меню в соответствии с индивидуальным заданием.
5. Для периодических действий период повтора брать из параметра Time.
6. Результаты выполнения должны выводится на экран в формате:
```
----------------------------Дата---Время----------------------------
                             Результаты
--------------------------------------------------------------------
```
7. Предусмотреть выход из скрипта по заданному условию и возврат в главное меню программы.
8. При необходимости параметры работы скрипта могут вводится в диалоговом режиме.
9. Все действия, производимые скриптом фиксировать в файле журнала.

<h3>Запуск</h3>
Для запуска скрипта нужного варианта выполните следующие команды из корня репозитория:

```shell
LAB_VARIANT=<НОМЕР_ВАРИАНТА>
chmod +x complex/$LAB_VARIANT/main.sh
./complex/$LAB_VARIANT/main.sh
```

<details>
<summary><h3>Скрипты</h3></summary>

**[Вариант 5](./complex/5)**
1. Поиск в двух указанных каталогах файлов с одинаковым содержимым. Вывод имен этих файлов и размера в строках.
2. Создание в текущем каталоге папки вида data-time до тех пор, пока в текущем каталоге не появится файл с именем stop. В каждую папку копировать из текущего каталога файлы, заканчивающиеся на символы а — в первую папку, b — во вторую папку и т. д.
3. При выходе удаление всех созданных папок и создание файла, в который записывается их количество.

**[Вариант 9](./complex/9)**
1. Определить разность между максимальным и минимальным размерами файлов во всех подкаталогах указанного каталога.
2. Анализировать изменение количества процессов запущенных указанным пользователем в системе. Результат выводить в виде диаграммы вида:
```
****    4 процесса
**      2 процесса
******  6 процессов
***     3 процесса
*       1 процесс
*       1 процесс
**      2 процесса
```
и т. д. В начале каждой строки выводить текущее время.

Выход при превышении количества процессов некоторой заданной границы.

3. При выходе из программы формирование списка процессов, появившихся в системе за время работы скрипта.
</details>
