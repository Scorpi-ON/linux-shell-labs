# linux-shell-labs

<details>
<summary><h2>Простые команды</h2></summary>

Для загрузки команд в оболочку выполните команду:
```shell
source simple.sh
```

После этого они станут доступны.

Чтобы реализовать поддержку скрытых файлов, везде, где применялась команда `ls -l`, необходимо дописать флаг `-A`.
 
**1.** `lx` **— вывести список файлов указанного каталога, у которых права на чтение, запись и выполнение только для создателя файла (т.е. rwx------), отсортировать их по имени в обратном порядке.**

Команда ls -lh $1 выводит всё содержание указаного каталога, а grep находит те строки, которые начинаются на -rwx------ (т. е. содержат файлы с требуемым набором прав).

<img width=75% src="https://github.com/user-attachments/assets/f65c2a91-8812-4d78-9031-f25834ffb084"/>
<br>
<br>

**2.** `pu` **— посчитать количество процессов, запущенных указанным пользователем.**

Команда ps с аргументом -u выводит список процессов, запущенных указанным пользователем. Модификатор h убирает заголовок перед списком. Для подсчёта остаётся вызвать команду wc. Флаг -l, означает подсчёт только строк (а не слов и символов).

<img width=75% src="https://github.com/user-attachments/assets/cb2611c9-811b-4c5c-8d79-7b21e35cd850" />
<br>
<br>

**3.** `pt` **— посчитать кол-во процессов, запущенных с указанного терминала.**

Команда ps c модификатором t выводит список процессов, запущенных с указанного терминала. Для подсчёта вновь используем модификатор h и передачу команде wc.

<img width=75% src="https://github.com/user-attachments/assets/9a67365e-6457-4177-baea-5867d9a53aea" />
<br>
<br>

**4.** `nx` **— количество исполнимых файлов в указанном каталоге.**

С помощью ls -l $1 выведем содержимое указанного каталога. Командой grep с шаблоном «^-.*x.* » найдём все строки, начинающиеся на - (такие строки описывают файлы) и содержащие x в триадах прав (хотя бы одна x означает, что файл является исполняемым для одной из групп пользователей). Флаг -с команды grep означает, что нужно вывести только число найденных строк.

<img width=75% src="https://github.com/user-attachments/assets/7b019955-2ee5-4677-ad59-e985868d397d" />
<br>
<br>

**5.** `npu` **— посчитать количество терминированных процессов, запущенных указанным пользователем.**

Терминированные процессы имеют статус T в списке процессов. Поскольку нам необходимо узнать их количество, воспользуемся аргументом -o и передадим ему одно поле — stat (статус процесса). Аргумент -u $1 выведет процессы указанного пользователя. Остаётся найти количество нужных статусов при помощи grep -c ‘^T’.
На скриншоте было создано и прервано 3 процесса, чтобы продемонстрировать работу скрипта.

<img width=75% src="https://github.com/user-attachments/assets/3b0b33e6-e2e6-4dd7-8ee0-c989699407b0" />
<br>
<br>

**6.** `mp` **— количество процессов, запущенных определенного числа.**

Запустим команду ps с модификатором h и флагом е для получения всех процессов без строки заголовка. Чтобы выбрать только даты, добавим аргументы -o lstart и -D %d.%m.%y. Теперь для поиска и подсчёта можно вводить дату в привычном формате.

<img width=75% src="https://github.com/user-attachments/assets/04004433-fdc6-4f69-b583-bde2f57b3f65" />
<br>
<br>

**7.** `tu` **— посчитать количество терминалов, с которых запущены процессы в текущий момент времени.**

Команда who в числе прочих данных выводит список активных терминалов. Подсчитаем их с помощью wc -l. При этом, поскольку с терминала pts/0 процессы не запускаются, отнимем от подсчитанного значения 1. Остаётся только вывести полученное арифметическое выражение с помощью echo.

<img width=75% src="https://github.com/user-attachments/assets/2892512e-de5f-4ef8-b6ae-a9c2f3f2b120" />
<br>
<br>

**8.** `bp` **— вывести информацию об указанном количестве процессов, имеющих наибольшее время использования процессора.**

Выведем список всех процессов командой ps -e. Также после аргумента -o укажем необходимые поля для вывода: пользователь, идентификатор процесса, процессорное время и команда. Чтобы отсортировать список по процессорному времени по убыванию используем аргумент --sort=-time. Чтобы вывести указанное количество строк из полученного списка, используем команду head. Аргумент -n задаёт число строк для вывода. Поскольку строка заголовка в данном случае нужна, к указанному числу прибавим 1.

<img width=75% src="https://github.com/user-attachments/assets/ce81da0f-5ae7-45e9-9052-2dea443de266" />
<br>
<br>

**9.** `bf` **— вывести информацию об указанном количестве файлов, имеющих наибольший размер.**

С помощью флага -S отсортируем вывод команды ls -lh по размеру файлов. Чтобы отобрать файлы из содержимого каталога, применим grep ‘^-‘. Чтобы выбрать только указанное количество файлов из топа, используем head -n $2.

<img width=75% src="https://github.com/user-attachments/assets/31071b65-2a57-4a34-91df-e17a68bd50e3" />
<br>
<br>

**10.** `fm` **— посчитать кол-во директорий в указанном каталоге, у которых права доступа: rwxrwxrwx.**

Выведем содержимое указанного каталога, после чего используем grep с шаблоном ‘^drwxrwxrwx’ (выбирает директории с полной триадой прав) и подсчитаем с помощью флага -c.

<img width=75% src="https://github.com/user-attachments/assets/eacb8836-a9bd-4c5b-aa4d-fe512c14ecb8" />
<br>
<br>

**11.** `ml` **— вывести информацию об указанном количестве файлов, имеющих наибольшее число связей.**

Число связей файлов выводится во втором столбце вывода команды ls -l. Поэтому, чтобы отсортировать файлы и директории по числу связей, передадим команде sort аргументы -rnk2 (числовая сортировка по убыванию по второму столбцу). Чтобы получить указанное количество файлов, применим команду head.

<img width=75% src="https://github.com/user-attachments/assets/58868b27-3d00-40bf-8a5e-43ffe5370d5f" />
<br>
<br>

**12.** `ll` **— список пользователей-владельцев файлов в указанном каталоге.**

Чтобы вычленить пользователей владельцев из содержимого каталога, применим команду awk. Чтобы выбрать из них уникальные имена, используем sort -u.

<img width=75% src="https://github.com/user-attachments/assets/703ea097-8f69-4cfb-9571-124b732f6f69" />
<br>
<br>

**13.** `rl` **— вывести список всех файлов, с датой создания, равной текущему числу.**

Для вывода содержимого каталога с датой создания применим аргумент --time=creation, а чтобы эта дата была в более привычном формате, добавим аргумент --time-style +%d.%m.%y. Текущую дату получим в этом же формате командой date. Остаётся только найти строчки, содержащие эту дату (а также - в начале строки как признак файла), при помощи grep.

<img width=75% src="https://github.com/user-attachments/assets/12b33de6-019e-40c5-9cb6-f5a56f0c2f44" />
<br>
<br>

**14.** `lr` **— вывести 5 последних процессов, запущенных root.**

По аналогии с командой bp (см. пункт 8) выведем интересующие нас колонки процессов root и с помощью аргумента --sort=-start отсортируем по времени создания по убыванию.

<img width=75% src="https://github.com/user-attachments/assets/5d401952-37ac-46b1-9795-cd9bb2d31f1c" />
<br>
<br>

**15.** `rc` **— вывести 5 процессов, запущенных studentom.**

Выведем все процессы, запущенные указанным пользователем, после чего выберем 5 из них (а также строку заголовка).

<img width=75% src="https://github.com/user-attachments/assets/a0c9883f-a80f-4922-8a18-7f8c8e2f1d0f" />
<br>
<br>

**16.** `cu` **— посчитать, какое количество пользователей сейчас работает в системе (имя уникально).**

Выведем работающих на данный момент пользователей командой w, отбросим строку заголовка флагом -h и подсчитаем оставшиеся строки пользователей.

<img width=75% src="https://github.com/user-attachments/assets/577b7673-b0ee-493d-86a7-7a71f1516070" />

</details>
